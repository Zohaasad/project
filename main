#include<iostream>
#include"String.h"
#include<"myvetor.h"
class logger{
    public:
    static logger & getInstance(){
        static logger instance;
        return instance;
    }
    void initialize(const String & filename ){
        if(log_file_.is_open()){
            cout<<"logger is already initialized "<<endl;
            return ;
        }
        log_file_.open(filename.c_str(),ios::out );
        if(!log_file_){
            cout<<"failed to open "<<filename<<endl;
            exit(EXIT_FAILURE);
        }
    }
    void cleanup(){
        if(log_file_.is_open()){
            log_file_.close();
        }
    }
    void writeerror(const String & error_message){
        if(!log_file_.is_open()){
            cout<<"logger is not initialized"<<endl;
           exit(EXIT_FAILURE);
        }
        time_t now =time(nullptr);
        tm* local_time=localtime(&now);
        char timestamp[20];
        strftime(timestamp,sizeof(timestamp),"%Y-%m-%d %H:%M:%S",local_time);
        
        log_file_<<"["<<timestamp<<"] error" <<error_message<<endl;
    }
    

    logger (const logger &)=delete;
    logger &operator=(const logger &)=delete;
     
private:
logger(){}
~logger(){}
ofstream log_file_;
};

class Card{
    protected:
    bool matched;
    public:
    Card():matched(false){}
    virtual ~Card(){}
    virtual String getsymbol() const=0;
    bool ismatched()const {
        return matched;
        
    }
    void setmatched(bool m ){
        matched=m;
    }
    virtual void display()const =0;
    
};
class simplecard: public Card{
    char symbol ;
    public:
    simplecard():symbol(' '){}
    
    simplecard(char s): symbol(s){}
    String getsymbol()const override{
        return String (&symbol);
    }
    void display()const override{
        cout<<symbol;
    }
};
class hardcard: public Card{
    String symbol;
    public:
    hardcard():symbol(" "){}
    hardcard(const String &s):symbol(s){}
    String getsymbol()const override{
        return symbol;
        
    }
    void display()const override {
        cout<<symbol;
    }
    
};
class Board {
    private:
    static Board* instance;
    static const int size=16;
    bool hardmode;
    simplecard sc[16];
    hardcard hc[16];
    Card * card[16];
    Board(): hardmode(false){}
    public:
    static Board *getinstance(){
        static Board instance;
        return &instance;
    }
    void sethardmode(bool hm){
        hardmode=hm;
    }
   
     void show(const myvector<bool>&revealed){
        try{
            cout<<"\nboard:\n";
            for(int i=0;i<size;i++){
                if(i%4==0)
                cout<<"\n";
                if(card[i]->ismatched()){card[i]->display();
                    cout<<" ";
                }
                else if(revealed[i]){card[i]->display();
                cout<<" ";}
                else 
                if(hardmode){
                    cout<<"****";
                }
                else cout<<"*";
            }
            cout<<"\n";
        }
        catch(const char *msg){
            logger::getInstance().writeerror(String ("exception in show ")+msg);
        }
    }
    int getsize()const {
       return size;
   }
   bool ishardmode()const {
       return hardmode;
   }
void showall(){
       try {
           cout<<"\n board previous state :\n";
           for(int i=0;i<size;i++){
               if(i%4==0)
               cout<<"\n";
               cout<<"["<<i<<"]";
               if(card[i]->ismatched()){
                   card[i]->display();
                   cout<<" ";
               }
               else 
               if(hardmode){
               cout<<"****";
                   
               }
               else cout<<"*";
           }
           cout<<"\n";
       }
       catch(const char*msg){
           logger::getInstance().writeerror(String("exception in show all: ")+msg);
           
       }
   }
   Card *getcard (int index){
       return card[index];
   }
   void setmatched(int i ,int j){
       try {
           card[i]->setmatched(true);
           card[j]->setmatched(true);
           
       }
       catch(const char *msg){
           logger::getInstance().writeerror(String("exception in set matched:")+msg);
           
       }
   }
    //msg stands for message 
    
};
Board *Board::instance=nullptr;
class player {
    protected:
    String name;
    int score;
    public:
    player (String n):name(n),score(0){}
    virtual~player(){}
    String getname()const {
        return name;
    }
    int getscore()const{
        return score;
    }
    void addscore(){
        score++;
    }
    virtual pair<int,int>pick(const myvector<bool>&revealed)=0; 
    
};
//we use pair because we have to return 2 position on board at same time to show if both the cards are same or different 



class humanplayer:public player {
    public:
    humanplayer(String n):player (n){}
    pair<int,int>pick(const myvector<bool>&revealed)override{
        try{
            
        
    int a=-1;
    int b=-1;
    bool valid=false;
    while(!valid){
        cout<<name<<", pick 2 cards (0 to 15 ) :";
        cin>>a>>b;
        if(cin.fail()){
            cout<<"error :invalid input type try again.\n";
            logger::getInstance().writeerror("invalid input type");
            cin.clear();
            cin.ignore(numeric_limits<streamsize>::max(),'\n');
           //if the user type the wrong input this lines rmoves all of it no matter how long so the game dosent break and ask again streamsize is just a type that is use to tell how much to rmove  and numericlimit <streamsize>::max()gives the biggest amount to ignore .
        
            continue;
        }
        if(a>=0&&a<16 &&b>=0&&b<16&&a!=b&&!revealed[a]&&!revealed[b]&&!Board::getinstance()->getcard(a)->ismatched()&&!Board::getinstance()->getcard(b)->ismatched()){
            valid=true;
        }
        else{
            cout<<"inavlid pick try again.\n";
            logger::getInstance().writeerror("invalid card pick attempt");
        }
        }
        return{a,b};
    }
    catch(const char *msg){
        logger::getInstance().writeerror(String("exception in human player ")+msg);
        throw;
    }
}
};
class aiplayer :public player{
    myvector<String>symbols;
    myvector<myvector<int >>indices;
    public:
    aiplayer(String n ):player(n){}
    void cleanupmemory(const myvector <bool>&revealed){
        try{
            int i=0;
            while(i<symbols.size()){
                myvector<int>&index=indices[i];
                int j=0;
                while(j<index.size()){
                    if(revealed[index[j]]||Board::getinstance()->getcard(index[j])->ismatched()){
                        index.deleteat(j);
                    }
                    else{
                        j++;
                    }
                }
                if(index.size()==0){
                    symbols.deleteat(i);
                    indices.deleteat(i);
                }
                else{
                    i++;
                }
            }
        }
        catch(const char*msg){
            logger::getInstance().writeerror(String("there is exception in ai player in clean up part ")+msg);
        }
    }
    
void updatememory (const myvector<bool>&revealed){
    try{
        for(int i =0;i<revealed.size();i++){
            if(revealed[i]&&!Board::getinstance()->getcard(i)->ismatched()){
                String value =Board::getinstance()->getcard(i)->getsymbol();
                int find=-1;
                for(int j=0;j<symbols.size();j++){
                    if(symbols[j]==value){
                        find=j;
                        break;
                    }
                }
                if(find==-1){
                    symbols.push(value);
                    myvector<int> v;
                    v.push(i);
                    indices.push(v);
                }
                else{
                    bool alreadythere =false;
                    for(int k=0;k<indices[find].size();k++){
                        if(indices[find][k]==i)
                        alreadythere=true;
                        
                    }
                    if(!alreadythere)
                    indices[find].push(i);
                }
                
            }
        }
    }
    catch(const char *msg){
        logger::getInstance().writeerror(String("exception in ai player in upadte memory part :")+msg);
    }
}
void remembercards(const myvector<bool>&revealed){
     updatememory(revealed);
 }

};

int main (){
return 0 ;
}
